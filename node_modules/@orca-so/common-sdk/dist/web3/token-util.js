"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TokenUtil = void 0;
const spl_token_1 = require("@solana/spl-token");
const web3_js_1 = require("@solana/web3.js");
const sha256_1 = require("@noble/hashes/sha256");
const tiny_invariant_1 = __importDefault(require("tiny-invariant"));
const math_1 = require("../math");
const web3_1 = require("../web3");
class TokenUtil {
    static isNativeMint(mint) {
        return mint.equals(spl_token_1.NATIVE_MINT);
    }
    static createWrappedNativeAccountInstruction(owner, amountIn, rentExemptLamports, payer, unwrapDestination, createAccountMethod = "keypair") {
        const payerKey = payer ?? owner;
        const unwrapDestinationKey = unwrapDestination ?? owner;
        switch (createAccountMethod) {
            case "ata":
                return createWrappedNativeAccountInstructionWithATA(owner, amountIn, rentExemptLamports, payerKey, unwrapDestinationKey);
            case "keypair":
                return createWrappedNativeAccountInstructionWithKeypair(owner, amountIn, rentExemptLamports, payerKey, unwrapDestinationKey);
            case "withSeed":
                return createWrappedNativeAccountInstructionWithSeed(owner, amountIn, rentExemptLamports, payerKey, unwrapDestinationKey);
            default:
                throw new Error(`Invalid createAccountMethod: ${createAccountMethod}`);
        }
    }
    static async createSendTokensToWalletInstruction(connection, sourceWallet, destinationWallet, tokenMint, tokenDecimals, amount, getAccountRentExempt, payer, allowPDASourceWallet = false) {
        (0, tiny_invariant_1.default)(!amount.eq(math_1.ZERO), "SendToken transaction must send more than 0 tokens.");
        (0, tiny_invariant_1.default)(!tokenMint.equals(spl_token_1.NATIVE_MINT_2022), "NATIVE_MINT_2022 is not supported.");
        if (tokenMint.equals(spl_token_1.NATIVE_MINT)) {
            const sendSolTxn = web3_js_1.SystemProgram.transfer({
                fromPubkey: sourceWallet,
                toPubkey: destinationWallet,
                lamports: BigInt(amount.toString()),
            });
            return {
                instructions: [sendSolTxn],
                cleanupInstructions: [],
                signers: [],
            };
        }
        const mintAccountInfo = await connection.getAccountInfo(tokenMint);
        if (mintAccountInfo === null)
            throw Error("Cannot fetch tokenMint.");
        const tokenProgram = mintAccountInfo.owner;
        const sourceTokenAccount = (0, spl_token_1.getAssociatedTokenAddressSync)(tokenMint, sourceWallet, allowPDASourceWallet, tokenProgram);
        const { address: destinationTokenAccount, ...destinationAtaIx } = await (0, web3_1.resolveOrCreateATA)(connection, destinationWallet, tokenMint, getAccountRentExempt, amount, payer, undefined, true);
        const transferIx = await (0, spl_token_1.createTransferCheckedWithTransferHookInstruction)(connection, sourceTokenAccount, tokenMint, destinationTokenAccount, sourceWallet, BigInt(amount.toString()), tokenDecimals, undefined, undefined, tokenProgram);
        return {
            instructions: destinationAtaIx.instructions.concat(transferIx),
            cleanupInstructions: destinationAtaIx.cleanupInstructions,
            signers: destinationAtaIx.signers,
        };
    }
}
exports.TokenUtil = TokenUtil;
function createWrappedNativeAccountInstructionWithATA(owner, amountIn, _rentExemptLamports, payerKey, unwrapDestinationKey) {
    const tempAccount = (0, spl_token_1.getAssociatedTokenAddressSync)(spl_token_1.NATIVE_MINT, owner);
    const instructions = [
        (0, spl_token_1.createAssociatedTokenAccountIdempotentInstruction)(payerKey, tempAccount, owner, spl_token_1.NATIVE_MINT),
    ];
    if (amountIn.gt(math_1.ZERO)) {
        instructions.push(web3_js_1.SystemProgram.transfer({
            fromPubkey: payerKey,
            toPubkey: tempAccount,
            lamports: amountIn.toNumber(),
        }));
        instructions.push((0, spl_token_1.createSyncNativeInstruction)(tempAccount));
    }
    const closeWSOLAccountInstruction = (0, spl_token_1.createCloseAccountInstruction)(tempAccount, unwrapDestinationKey, owner);
    return {
        address: tempAccount,
        tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
        instructions,
        cleanupInstructions: [closeWSOLAccountInstruction],
        signers: [],
    };
}
function createWrappedNativeAccountInstructionWithKeypair(owner, amountIn, rentExemptLamports, payerKey, unwrapDestinationKey) {
    const tempAccount = new web3_js_1.Keypair();
    const createAccountInstruction = web3_js_1.SystemProgram.createAccount({
        fromPubkey: payerKey,
        newAccountPubkey: tempAccount.publicKey,
        lamports: amountIn.toNumber() + rentExemptLamports,
        space: spl_token_1.AccountLayout.span,
        programId: spl_token_1.TOKEN_PROGRAM_ID,
    });
    const initAccountInstruction = (0, spl_token_1.createInitializeAccountInstruction)(tempAccount.publicKey, spl_token_1.NATIVE_MINT, owner);
    const closeWSOLAccountInstruction = (0, spl_token_1.createCloseAccountInstruction)(tempAccount.publicKey, unwrapDestinationKey, owner);
    return {
        address: tempAccount.publicKey,
        tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
        instructions: [createAccountInstruction, initAccountInstruction],
        cleanupInstructions: [closeWSOLAccountInstruction],
        signers: [tempAccount],
    };
}
function createWrappedNativeAccountInstructionWithSeed(owner, amountIn, rentExemptLamports, payerKey, unwrapDestinationKey) {
    const seed = web3_js_1.Keypair.generate().publicKey.toBase58().slice(0, 32);
    const tempAccount = (() => {
        const fromPublicKey = owner;
        const programId = spl_token_1.TOKEN_PROGRAM_ID;
        const buffer = Buffer.concat([
            fromPublicKey.toBuffer(),
            Buffer.from(seed),
            programId.toBuffer(),
        ]);
        const publicKeyBytes = (0, sha256_1.sha256)(buffer);
        return new web3_js_1.PublicKey(publicKeyBytes);
    })();
    const createAccountInstruction = web3_js_1.SystemProgram.createAccountWithSeed({
        fromPubkey: payerKey,
        basePubkey: owner,
        seed,
        newAccountPubkey: tempAccount,
        lamports: amountIn.toNumber() + rentExemptLamports,
        space: spl_token_1.AccountLayout.span,
        programId: spl_token_1.TOKEN_PROGRAM_ID,
    });
    const initAccountInstruction = (0, spl_token_1.createInitializeAccountInstruction)(tempAccount, spl_token_1.NATIVE_MINT, owner);
    const closeWSOLAccountInstruction = (0, spl_token_1.createCloseAccountInstruction)(tempAccount, unwrapDestinationKey, owner);
    return {
        address: tempAccount,
        tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
        instructions: [createAccountInstruction, initAccountInstruction],
        cleanupInstructions: [closeWSOLAccountInstruction],
        signers: [],
    };
}
//# sourceMappingURL=token-util.js.map