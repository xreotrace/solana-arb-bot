import type { AddressLookupTableAccount, Commitment, Connection, PublicKey, RecentPrioritizationFees, SendOptions, Signer } from "@solana/web3.js";
import { Transaction, VersionedTransaction } from "@solana/web3.js";
import type { Wallet } from "../wallet";
import type { Instruction, TransactionPayload } from "./types";
export type BuildOptions = LegacyBuildOption | V0BuildOption;
type LegacyBuildOption = {
    maxSupportedTransactionVersion: "legacy";
} & BaseBuildOption;
type V0BuildOption = {
    maxSupportedTransactionVersion: number;
    lookupTableAccounts?: AddressLookupTableAccount[];
} & BaseBuildOption;
type BaseBuildOption = {
    latestBlockhash?: {
        blockhash: string;
        lastValidBlockHeight: number;
    };
    computeBudgetOption?: ComputeBudgetOption;
    blockhashCommitment: Commitment;
};
type ComputeBudgetOption = {
    type: "none";
} | {
    type: "fixed";
    priorityFeeLamports: number;
    computeBudgetLimit?: number;
    jitoTipLamports?: number;
    accountDataSizeLimit?: number;
} | {
    type: "auto";
    maxPriorityFeeLamports?: number;
    minPriorityFeeLamports?: number;
    jitoTipLamports?: number;
    accountDataSizeLimit?: number;
    computeLimitMargin?: number;
    computePricePercentile?: number;
    getPriorityFeePerUnit?: (lockedWritableAccounts: PublicKey[]) => Promise<RecentPrioritizationFees[]>;
};
type SyncBuildOptions = BuildOptions & Required<BaseBuildOption>;
export type TransactionBuilderOptions = {
    defaultBuildOption: BuildOptions;
    defaultSendOption: SendOptions;
    defaultConfirmationCommitment: Commitment;
};
export declare const defaultTransactionBuilderOptions: TransactionBuilderOptions;
export declare class TransactionBuilder {
    readonly connection: Connection;
    readonly wallet: Wallet;
    private instructions;
    private signers;
    readonly opts: TransactionBuilderOptions;
    constructor(connection: Connection, wallet: Wallet, defaultOpts?: TransactionBuilderOptions);
    addInstruction(instruction: Instruction): TransactionBuilder;
    addInstructions(instructions: Instruction[]): TransactionBuilder;
    prependInstruction(instruction: Instruction): TransactionBuilder;
    prependInstructions(instructions: Instruction[]): TransactionBuilder;
    addSigner(signer: Signer): TransactionBuilder;
    isEmpty(): boolean;
    compressIx(compressPost: boolean): Instruction;
    txnSize(userOptions?: Partial<BuildOptions>): number;
    buildSync(options: SyncBuildOptions): TransactionPayload;
    estimateFee(getPriorityFeePerUnit?: (lockedWritableAccounts: PublicKey[]) => Promise<RecentPrioritizationFees[]>, computeLimitMargin?: number, selectionPercentile?: number, lookupTableAccounts?: AddressLookupTableAccount[]): Promise<{
        estConsumedComputeUnits: number;
        estPriorityFeePerUnitInLamports: RecentPrioritizationFees[];
        estPriorityFeeInLamports: number;
    }>;
    build(userOptions?: Partial<BuildOptions>): Promise<TransactionPayload>;
    buildAndExecute(options?: Partial<BuildOptions>, sendOptions?: Partial<SendOptions>, confirmCommitment?: Commitment): Promise<string>;
}
export declare const isVersionedTransaction: (tx: Transaction | VersionedTransaction) => tx is VersionedTransaction;
export {};
