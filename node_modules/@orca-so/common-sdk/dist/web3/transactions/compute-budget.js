"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DEFAULT_MAX_COMPUTE_UNIT_LIMIT = exports.DEFAULT_MIN_PRIORITY_FEE_LAMPORTS = exports.DEFAULT_MAX_PRIORITY_FEE_LAMPORTS = exports.DEFAULT_PRIORITY_FEE_PERCENTILE = exports.MICROLAMPORTS_PER_LAMPORT = void 0;
exports.estimateComputeBudgetLimit = estimateComputeBudgetLimit;
exports.getPriorityFeeInLamports = getPriorityFeeInLamports;
exports.getLockWritableAccounts = getLockWritableAccounts;
exports.setLoadedAccountsDataSizeLimitInstruction = setLoadedAccountsDataSizeLimitInstruction;
const web3_js_1 = require("@solana/web3.js");
const bn_js_1 = __importDefault(require("bn.js"));
exports.MICROLAMPORTS_PER_LAMPORT = 1_000_000;
exports.DEFAULT_PRIORITY_FEE_PERCENTILE = 0.9;
exports.DEFAULT_MAX_PRIORITY_FEE_LAMPORTS = 1000000;
exports.DEFAULT_MIN_PRIORITY_FEE_LAMPORTS = 0;
exports.DEFAULT_MAX_COMPUTE_UNIT_LIMIT = 1_400_000;
async function estimateComputeBudgetLimit(connection, instructions, lookupTableAccounts, payer, margin) {
    try {
        const txMainInstructions = instructions.flatMap((instruction) => instruction.instructions);
        const txCleanupInstruction = instructions.flatMap((instruction) => instruction.cleanupInstructions);
        const txMessage = new web3_js_1.TransactionMessage({
            recentBlockhash: web3_js_1.PublicKey.default.toBase58(),
            payerKey: payer,
            instructions: [...txMainInstructions, ...txCleanupInstruction],
        }).compileToV0Message(lookupTableAccounts);
        const tx = new web3_js_1.VersionedTransaction(txMessage);
        const simulation = await connection.simulateTransaction(tx, {
            sigVerify: false,
            replaceRecentBlockhash: true,
        });
        if (!simulation.value.unitsConsumed) {
            return exports.DEFAULT_MAX_COMPUTE_UNIT_LIMIT;
        }
        const marginUnits = Math.max(100_000, margin * simulation.value.unitsConsumed);
        const estimatedUnits = Math.ceil(simulation.value.unitsConsumed + marginUnits);
        return Math.min(exports.DEFAULT_MAX_COMPUTE_UNIT_LIMIT, estimatedUnits);
    }
    catch {
        return exports.DEFAULT_MAX_COMPUTE_UNIT_LIMIT;
    }
}
async function getPriorityFeeInLamports(connection, computeBudgetLimit, lockedWritableAccounts, percentile = exports.DEFAULT_PRIORITY_FEE_PERCENTILE, getRecentPrioritizationFees) {
    const recentPriorityFees = await (getRecentPrioritizationFees
        ? getRecentPrioritizationFees(lockedWritableAccounts)
        : connection.getRecentPrioritizationFees({
            lockedWritableAccounts,
        }));
    const priorityFee = getPriorityFeeSuggestion(recentPriorityFees, percentile);
    return (priorityFee * computeBudgetLimit) / exports.MICROLAMPORTS_PER_LAMPORT;
}
function getPriorityFeeSuggestion(recentPriorityFees, percentile) {
    const sortedPriorityFees = recentPriorityFees.sort((a, b) => a.prioritizationFee - b.prioritizationFee);
    const percentileIndex = Math.min(Math.max(Math.floor(sortedPriorityFees.length * percentile), 0), sortedPriorityFees.length - 1);
    return sortedPriorityFees[percentileIndex].prioritizationFee;
}
function getLockWritableAccounts(instructions) {
    return instructions
        .flatMap((instruction) => [
        ...instruction.instructions,
        ...instruction.cleanupInstructions,
    ])
        .flatMap((instruction) => instruction.keys)
        .filter((key) => key.isWritable)
        .map((key) => key.pubkey);
}
const SET_LOADED_ACCOUNTS_DATA_SIZE_LIMIT_INSTRUCTION_DISCRIMINATOR = Buffer.from([0x04]);
function setLoadedAccountsDataSizeLimitInstruction(dataSizeLimit) {
    const dataSizeLimitBn = new bn_js_1.default(dataSizeLimit);
    return new web3_js_1.TransactionInstruction({
        programId: web3_js_1.ComputeBudgetProgram.programId,
        data: Buffer.concat([
            SET_LOADED_ACCOUNTS_DATA_SIZE_LIMIT_INSTRUCTION_DISCRIMINATOR,
            dataSizeLimitBn.toArrayLike(Buffer, "le", 4),
        ]),
        keys: [],
    });
}
//# sourceMappingURL=compute-budget.js.map