"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isVersionedTransaction = exports.TransactionBuilder = exports.defaultTransactionBuilderOptions = void 0;
const web3_js_1 = require("@solana/web3.js");
const compute_budget_1 = require("./compute-budget");
const constants_1 = require("./constants");
const jito_tip_1 = require("./jito-tip");
const LEGACY_TX_UNIQUE_KEYS_LIMIT = 35;
exports.defaultTransactionBuilderOptions = {
    defaultBuildOption: {
        maxSupportedTransactionVersion: 0,
        blockhashCommitment: "confirmed",
    },
    defaultSendOption: {
        skipPreflight: false,
        preflightCommitment: "confirmed",
        maxRetries: 3,
    },
    defaultConfirmationCommitment: "confirmed",
};
class TransactionBuilder {
    connection;
    wallet;
    instructions;
    signers;
    opts;
    constructor(connection, wallet, defaultOpts) {
        this.connection = connection;
        this.wallet = wallet;
        this.instructions = [];
        this.signers = [];
        this.opts = defaultOpts ?? exports.defaultTransactionBuilderOptions;
    }
    addInstruction(instruction) {
        this.instructions.push(instruction);
        return this;
    }
    addInstructions(instructions) {
        this.instructions = this.instructions.concat(instructions);
        return this;
    }
    prependInstruction(instruction) {
        this.instructions.unshift(instruction);
        return this;
    }
    prependInstructions(instructions) {
        this.instructions = instructions.concat(this.instructions);
        return this;
    }
    addSigner(signer) {
        this.signers.push(signer);
        return this;
    }
    isEmpty() {
        return this.instructions.length == 0;
    }
    compressIx(compressPost) {
        let instructions = [];
        let cleanupInstructions = [];
        let signers = [];
        this.instructions.forEach((curr) => {
            instructions = instructions.concat(curr.instructions);
            cleanupInstructions =
                curr.cleanupInstructions.concat(cleanupInstructions);
            signers = signers.concat(curr.signers);
        });
        if (compressPost) {
            instructions = instructions.concat(cleanupInstructions);
            cleanupInstructions = [];
        }
        return {
            instructions: [...instructions],
            cleanupInstructions: [...cleanupInstructions],
            signers,
        };
    }
    txnSize(userOptions) {
        const finalOptions = {
            ...this.opts.defaultBuildOption,
            ...userOptions,
            latestBlockhash: constants_1.MEASUREMENT_BLOCKHASH,
            computeBudgetOption: this.opts.defaultBuildOption.computeBudgetOption ?? {
                type: "none",
            },
        };
        if (this.isEmpty()) {
            return 0;
        }
        const request = this.buildSync(finalOptions);
        const tx = request.transaction;
        return (0, exports.isVersionedTransaction)(tx) ? measureV0Tx(tx) : measureLegacyTx(tx);
    }
    buildSync(options) {
        const { latestBlockhash, maxSupportedTransactionVersion, computeBudgetOption, } = options;
        const ix = this.compressIx(true);
        let prependInstructions = [];
        if (computeBudgetOption.type === "fixed") {
            const computeLimit = computeBudgetOption.computeBudgetLimit ??
                compute_budget_1.DEFAULT_MAX_COMPUTE_UNIT_LIMIT;
            const microLamports = Math.floor((computeBudgetOption.priorityFeeLamports * compute_budget_1.MICROLAMPORTS_PER_LAMPORT) /
                computeLimit);
            prependInstructions = [
                web3_js_1.ComputeBudgetProgram.setComputeUnitLimit({
                    units: computeLimit,
                }),
            ];
            if (microLamports > 0) {
                prependInstructions.push(web3_js_1.ComputeBudgetProgram.setComputeUnitPrice({
                    microLamports,
                }));
            }
            if (computeBudgetOption.accountDataSizeLimit) {
                prependInstructions.push((0, compute_budget_1.setLoadedAccountsDataSizeLimitInstruction)(computeBudgetOption.accountDataSizeLimit));
            }
            if (computeBudgetOption.jitoTipLamports &&
                computeBudgetOption.jitoTipLamports > 0) {
                prependInstructions.push(web3_js_1.SystemProgram.transfer({
                    fromPubkey: this.wallet.publicKey,
                    toPubkey: (0, jito_tip_1.getJitoTipAddress)(),
                    lamports: computeBudgetOption.jitoTipLamports,
                }));
            }
        }
        if (computeBudgetOption.type === "auto") {
            prependInstructions = [
                web3_js_1.ComputeBudgetProgram.setComputeUnitLimit({
                    units: compute_budget_1.DEFAULT_MAX_COMPUTE_UNIT_LIMIT,
                }),
                web3_js_1.ComputeBudgetProgram.setComputeUnitPrice({
                    microLamports: 0,
                }),
            ];
            if (computeBudgetOption.accountDataSizeLimit) {
                prependInstructions.push((0, compute_budget_1.setLoadedAccountsDataSizeLimitInstruction)(computeBudgetOption.accountDataSizeLimit));
            }
            if (computeBudgetOption.jitoTipLamports &&
                computeBudgetOption.jitoTipLamports > 0) {
                prependInstructions.push(web3_js_1.SystemProgram.transfer({
                    fromPubkey: this.wallet.publicKey,
                    toPubkey: (0, jito_tip_1.getJitoTipAddress)(),
                    lamports: computeBudgetOption.jitoTipLamports,
                }));
            }
        }
        const allSigners = ix.signers.concat(this.signers);
        const recentBlockhash = latestBlockhash;
        if (maxSupportedTransactionVersion === "legacy") {
            const transaction = new web3_js_1.Transaction({
                ...recentBlockhash,
                feePayer: this.wallet.publicKey,
            });
            if (prependInstructions.length > 0) {
                transaction.add(...prependInstructions);
            }
            transaction.add(...ix.instructions);
            transaction.feePayer = this.wallet.publicKey;
            return {
                transaction: transaction,
                signers: allSigners,
                recentBlockhash,
            };
        }
        const txnMsg = new web3_js_1.TransactionMessage({
            recentBlockhash: recentBlockhash.blockhash,
            payerKey: this.wallet.publicKey,
            instructions: [...prependInstructions, ...ix.instructions],
        });
        const { lookupTableAccounts } = options;
        const msg = txnMsg.compileToV0Message(lookupTableAccounts);
        const v0txn = new web3_js_1.VersionedTransaction(msg);
        return {
            transaction: v0txn,
            signers: allSigners,
            recentBlockhash,
        };
    }
    async estimateFee(getPriorityFeePerUnit, computeLimitMargin, selectionPercentile, lookupTableAccounts) {
        const estConsumedComputeUnits = await (0, compute_budget_1.estimateComputeBudgetLimit)(this.connection, this.instructions, lookupTableAccounts, this.wallet.publicKey, computeLimitMargin ?? 0.1);
        const lockedWritableAccounts = (0, compute_budget_1.getLockWritableAccounts)(this.instructions);
        const estPriorityFeePerUnitInLamports = await (getPriorityFeePerUnit
            ? getPriorityFeePerUnit(lockedWritableAccounts)
            : this.connection.getRecentPrioritizationFees({
                lockedWritableAccounts,
            }));
        const estPriorityFeeInLamports = await (0, compute_budget_1.getPriorityFeeInLamports)(this.connection, estConsumedComputeUnits, lockedWritableAccounts, selectionPercentile ?? compute_budget_1.DEFAULT_PRIORITY_FEE_PERCENTILE, getPriorityFeePerUnit);
        return {
            estConsumedComputeUnits,
            estPriorityFeePerUnitInLamports,
            estPriorityFeeInLamports,
        };
    }
    async build(userOptions) {
        const finalOptions = { ...this.opts.defaultBuildOption, ...userOptions };
        const { latestBlockhash, blockhashCommitment, computeBudgetOption } = finalOptions;
        let recentBlockhash = latestBlockhash;
        if (!recentBlockhash) {
            recentBlockhash =
                await this.connection.getLatestBlockhash(blockhashCommitment);
        }
        let finalComputeBudgetOption = computeBudgetOption ?? { type: "none" };
        const lookupTableAccounts = finalOptions.maxSupportedTransactionVersion === "legacy"
            ? undefined
            : finalOptions.lookupTableAccounts;
        if (finalComputeBudgetOption.type === "auto") {
            const computeBudgetLimit = await (0, compute_budget_1.estimateComputeBudgetLimit)(this.connection, this.instructions, lookupTableAccounts, this.wallet.publicKey, finalComputeBudgetOption.computeLimitMargin ?? 0.1);
            const percentile = finalComputeBudgetOption.computePricePercentile ??
                compute_budget_1.DEFAULT_PRIORITY_FEE_PERCENTILE;
            const priorityFee = await (0, compute_budget_1.getPriorityFeeInLamports)(this.connection, computeBudgetLimit, (0, compute_budget_1.getLockWritableAccounts)(this.instructions), percentile, finalComputeBudgetOption.getPriorityFeePerUnit);
            const maxPriorityFeeLamports = finalComputeBudgetOption.maxPriorityFeeLamports ??
                compute_budget_1.DEFAULT_MAX_PRIORITY_FEE_LAMPORTS;
            const minPriorityFeeLamports = finalComputeBudgetOption.minPriorityFeeLamports ??
                compute_budget_1.DEFAULT_MIN_PRIORITY_FEE_LAMPORTS;
            const priorityFeeLamports = Math.max(Math.min(priorityFee, maxPriorityFeeLamports), minPriorityFeeLamports);
            finalComputeBudgetOption = {
                type: "fixed",
                priorityFeeLamports,
                computeBudgetLimit,
                accountDataSizeLimit: finalComputeBudgetOption.accountDataSizeLimit,
                jitoTipLamports: finalComputeBudgetOption.jitoTipLamports,
            };
        }
        else if (finalComputeBudgetOption.type === "fixed" &&
            finalComputeBudgetOption.computeBudgetLimit === undefined) {
            const computeBudgetLimit = await (0, compute_budget_1.estimateComputeBudgetLimit)(this.connection, this.instructions, lookupTableAccounts, this.wallet.publicKey, 0.1);
            finalComputeBudgetOption = {
                ...finalComputeBudgetOption,
                computeBudgetLimit,
            };
        }
        return this.buildSync({
            ...finalOptions,
            latestBlockhash: recentBlockhash,
            computeBudgetOption: finalComputeBudgetOption,
        });
    }
    async buildAndExecute(options, sendOptions, confirmCommitment) {
        const sendOpts = { ...this.opts.defaultSendOption, ...sendOptions };
        const btx = await this.build(options);
        const txn = btx.transaction;
        const resolvedConfirmCommitment = confirmCommitment ?? this.opts.defaultConfirmationCommitment;
        let txId;
        if ((0, exports.isVersionedTransaction)(txn)) {
            const signedTxn = await this.wallet.signTransaction(txn);
            signedTxn.sign(btx.signers);
            txId = await this.connection.sendTransaction(signedTxn, sendOpts);
        }
        else {
            const signedTxn = await this.wallet.signTransaction(txn);
            btx.signers
                .filter((s) => s !== undefined)
                .forEach((keypair) => signedTxn.partialSign(keypair));
            txId = await this.connection.sendRawTransaction(signedTxn.serialize(), sendOpts);
        }
        const result = await this.connection.confirmTransaction({
            signature: txId,
            ...btx.recentBlockhash,
        }, resolvedConfirmCommitment);
        const confirmTxErr = result.value.err;
        if (confirmTxErr) {
            throw new Error(confirmTxErr.toString());
        }
        return txId;
    }
}
exports.TransactionBuilder = TransactionBuilder;
const isVersionedTransaction = (tx) => {
    return "version" in tx;
};
exports.isVersionedTransaction = isVersionedTransaction;
function measureLegacyTx(tx) {
    const uniqueKeys = new Set();
    for (const instruction of tx.instructions) {
        for (const key of instruction.keys) {
            uniqueKeys.add(key.pubkey.toBase58());
        }
        uniqueKeys.add(instruction.programId.toBase58());
    }
    if (uniqueKeys.size > LEGACY_TX_UNIQUE_KEYS_LIMIT) {
        throw new Error("Unable to measure transaction size. Too many unique keys in transaction.");
    }
    try {
        const serialized = tx.serialize({ requireAllSignatures: false });
        return serialized.length;
    }
    catch {
        throw new Error("Unable to measure transaction size. Unable to serialize transaction.");
    }
}
function measureV0Tx(tx) {
    let serialized;
    try {
        serialized = tx.serialize();
    }
    catch {
        throw new Error("Unable to measure transaction size. Unable to serialize transaction.");
    }
    if (serialized.length > web3_js_1.PACKET_DATA_SIZE) {
        throw new Error("Unable to measure transaction size. Transaction too large.");
    }
    return serialized.length;
}
//# sourceMappingURL=transactions-builder.js.map