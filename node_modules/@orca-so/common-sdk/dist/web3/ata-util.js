"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveOrCreateATA = resolveOrCreateATA;
exports.resolveOrCreateATAs = resolveOrCreateATAs;
const spl_token_1 = require("@solana/spl-token");
const math_1 = require("../math");
const network_1 = require("./network");
const token_util_1 = require("./token-util");
const types_1 = require("./transactions/types");
async function resolveOrCreateATA(connection, ownerAddress, tokenMint, getAccountRentExempt, wrappedSolAmountIn = math_1.ZERO, payer = ownerAddress, modeIdempotent = false, allowPDAOwnerAddress = false, wrappedSolAccountCreateMethod = "keypair") {
    const instructions = await resolveOrCreateATAs(connection, ownerAddress, [{ tokenMint, wrappedSolAmountIn }], getAccountRentExempt, payer, modeIdempotent, allowPDAOwnerAddress, wrappedSolAccountCreateMethod);
    return instructions[0];
}
async function resolveOrCreateATAs(connection, ownerAddress, requests, getAccountRentExempt, payer = ownerAddress, modeIdempotent = false, allowPDAOwnerAddress = false, wrappedSolAccountCreateMethod = "keypair") {
    const nonNativeMints = requests.filter(({ tokenMint }) => !tokenMint.equals(spl_token_1.NATIVE_MINT));
    const nativeMints = requests.filter(({ tokenMint }) => tokenMint.equals(spl_token_1.NATIVE_MINT));
    const nativeMint2022 = requests.filter(({ tokenMint }) => tokenMint.equals(spl_token_1.NATIVE_MINT_2022));
    if (nativeMints.length > 1) {
        throw new Error("Cannot resolve multiple WSolAccounts");
    }
    if (nativeMint2022.length > 0) {
        throw new Error("NATIVE_MINT_2022 is not supported");
    }
    let instructionMap = {};
    if (nonNativeMints.length > 0) {
        const mints = await (0, network_1.getMultipleParsedAccounts)(connection, nonNativeMints.map((a) => a.tokenMint), network_1.ParsableMintInfo);
        const nonNativeAddresses = nonNativeMints.map(({ tokenMint }, index) => (0, spl_token_1.getAssociatedTokenAddressSync)(tokenMint, ownerAddress, allowPDAOwnerAddress, mints[index].tokenProgram));
        const tokenAccounts = await (0, network_1.getMultipleParsedAccounts)(connection, nonNativeAddresses, network_1.ParsableTokenAccountInfo);
        tokenAccounts.forEach((tokenAccount, index) => {
            const ataAddress = nonNativeAddresses[index];
            let resolvedInstruction;
            if (tokenAccount) {
                if (!tokenAccount.owner.equals(ownerAddress)) {
                    throw new Error(`ATA with change of ownership detected: ${ataAddress.toBase58()}`);
                }
                resolvedInstruction = {
                    address: ataAddress,
                    tokenProgram: tokenAccount.tokenProgram,
                    ...types_1.EMPTY_INSTRUCTION,
                };
            }
            else {
                const createAtaInstruction = modeIdempotent
                    ? (0, spl_token_1.createAssociatedTokenAccountIdempotentInstruction)(payer, ataAddress, ownerAddress, nonNativeMints[index].tokenMint, mints[index].tokenProgram)
                    : (0, spl_token_1.createAssociatedTokenAccountInstruction)(payer, ataAddress, ownerAddress, nonNativeMints[index].tokenMint, mints[index].tokenProgram);
                resolvedInstruction = {
                    address: ataAddress,
                    tokenProgram: mints[index].tokenProgram,
                    instructions: [createAtaInstruction],
                    cleanupInstructions: [],
                    signers: [],
                };
            }
            instructionMap[nonNativeMints[index].tokenMint.toBase58()] =
                resolvedInstruction;
        });
    }
    if (nativeMints.length > 0) {
        const accountRentExempt = await getAccountRentExempt();
        const wrappedSolAmountIn = nativeMints[0]?.wrappedSolAmountIn || math_1.ZERO;
        instructionMap[spl_token_1.NATIVE_MINT.toBase58()] =
            token_util_1.TokenUtil.createWrappedNativeAccountInstruction(ownerAddress, wrappedSolAmountIn, accountRentExempt, payer, undefined, wrappedSolAccountCreateMethod);
    }
    return requests.map(({ tokenMint }) => instructionMap[tokenMint.toBase58()]);
}
//# sourceMappingURL=ata-util.js.map