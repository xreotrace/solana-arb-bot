"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getGlobalFarmAddress = exports.getAuthorityAndNonce = void 0;
const web3_js_1 = require("@solana/web3.js");
const instructions_1 = require("../instructions");
class GlobalFarm {
    constructor(params) {
        this.publicKey = params.publicKey;
        this.isInitialized = params.isInitialized;
        this.tokenProgramId = params.publicKey;
        this.authority = params.authority;
        this.nonce = params.nonce;
        this.emissionsAuthority = params.emissionsAuthority;
        this.removeRewardsAuthority = params.removeRewardsAuthority;
        this.baseTokenMint = params.baseTokenMint;
        this.baseTokenVault = params.baseTokenVault;
        this.rewardTokenVault = params.rewardTokenVault;
        this.farmTokenMint = params.farmTokenMint;
        this.emissionsPerSecondNumerator = params.emissionsPerSecondNumerator;
        this.emissionsPerSecondDenominator = params.emissionsPerSecondDenominator;
        this.lastUpdatedTimestamp = params.lastUpdatedTimestamp;
        this.cumulativeEmissionsPerFarmToken =
            params.cumulativeEmissionsPerFarmToken;
    }
    constructSetEmissionsPerSecondIx(numerator, denominator, programId) {
        return instructions_1.constructSetEmissionsPerSecondIx(this.emissionsAuthority, this.publicKey, this.baseTokenVault, programId, numerator, denominator);
    }
    toString() {
        return JSON.stringify({
            publicKey: this.publicKey.toBase58(),
            isInitialized: this.isInitialized,
            authority: this.authority.toBase58(),
            nonce: this.nonce,
            tokenProgramId: this.tokenProgramId.toBase58(),
            emissionsAuthority: this.emissionsAuthority.toBase58(),
            removeRewardsAuthority: this.removeRewardsAuthority.toBase58(),
            baseTokenMint: this.baseTokenMint.toBase58(),
            baseTokenVault: this.baseTokenVault.toBase58(),
            rewardTokenVault: this.rewardTokenVault.toBase58(),
            farmTokenMint: this.farmTokenMint.toBase58(),
            emissionsPerSecondNumerator: this.emissionsPerSecondNumerator.toString(),
            emissionsPerSecondDenominator: this.emissionsPerSecondDenominator.toString(),
            lastUpdatedTimestamp: this.lastUpdatedTimestamp.toString(),
            cumulativeEmissionsPerFarmToken: this.cumulativeEmissionsPerFarmToken.toString(),
        }, null, 2);
    }
}
exports.default = GlobalFarm;
/**
 * @returns The PDA used for this Aquafarm instance (generated by using the same
 *  seeds as the smart contract: global farm state pubkey + saved nonce)
 */
function getAuthorityAndNonce(publicKey, programId) {
    return __awaiter(this, void 0, void 0, function* () {
        return web3_js_1.PublicKey.findProgramAddress([publicKey.toBuffer()], programId);
    });
}
exports.getAuthorityAndNonce = getAuthorityAndNonce;
function getGlobalFarmAddress(baseTokenMint, rewardTokenMint, funder, tokenProgramId, programId) {
    return __awaiter(this, void 0, void 0, function* () {
        return web3_js_1.PublicKey.findProgramAddress([
            baseTokenMint.toBuffer(),
            rewardTokenMint.toBuffer(),
            funder.toBuffer(),
            tokenProgramId.toBuffer(),
        ], programId);
    });
}
exports.getGlobalFarmAddress = getGlobalFarmAddress;
//# sourceMappingURL=GlobalFarm.js.map